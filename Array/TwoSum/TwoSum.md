# 两数之和

题目如下:

给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。
你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。

## 示例:

给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9

所以返回 [0, 1]

## 思路

这道题利用简单的双循环，就可以完成。

尝试减少 1 次循环，减少复杂度使它变成 n。

核心思路就是，利用到 **集合容器**。

### 数据结构具象化

数组可以看做一个队列或者栈，对应现实生活的 **羽毛球筒**。

我们的对象，也就是数字，当作**有记号的羽毛球** 。

集合容器 ，使用字典，看作一个 **盆** 。

### 比较行为生活化

有了上面的前提，现在要根据条件 (a+b = x)，找 2 个羽毛球。

我们只要把羽毛球筒的球，一个个拿出来，扔到盆里，在扔球的过程中进行查找。

从球筒拿一次球，手上拿着的球 b，就看一次盆里有没有满足条件的球(a).

```
  //伪代码
  //定义字典
  Dict  numDict = Dict.new
  //进行循环取出
  for (int i=0;i++;i<numList.count){
      Int    num     = numList[i]
      Int    findNum = target-num;
      
      Number findIndex = numDict[@(findNum)];
      if(findIndex){//关键比较，如果能从找到合法的 Number,就完成任务,返回索引值
         return [findIndex,i];
      }
      
      //非常重要--包装数字进行存储。
      //num 数字作为键，索引 i 作为值
      dict[@(num)] = @(i);
   }
   //没有符合条件的
   return nil;

```

<img src="https://zenon-1255868537.cos.ap-guangzhou.myqcloud.com/blogPicture/20210221133000.jpg" style="zoom:50%;" />



### 扩展

这类思路，不局限于相加的和。

如果是要根据几个数的关系做计算比较，如相减/相乘/相除等等，然后存储在类似 **队列/栈** 的结构，都可以利用这种思路。

