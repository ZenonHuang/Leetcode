# 移动零

给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。

## 示例:

输入: [0,1,0,3,12]
输出: [1,3,12,0,0]

## 说明:

	1.	必须在原数组上操作，不能拷贝额外的数组。
	2.	尽量减少操作次数。



## 思路

核心思路：

- 利用双指针来做，2 次循环
- 利用双指针，1 次循环

### 双指针 2 次循环

这里的核心思路，利用快慢指针之间的“距离”。

- 快指针一直不停向前走，遍历数组
- 慢指针。当快指针不为0时，慢指针跟着一起走；快指针遇 0 ，慢指针不动

这样当一次遍历之后（快指针循环完成），慢指针之后的位置都可以变成 0 。

然而还有一个关键的地方，需要理解清楚：

> 因为要保持顺序，移动过程中，需要变换数组的值。即：将为 0 的位置，替换为后面一个不为 0 的值。

表示出来就是 ： 

```
		int slow = 0;
		for(int fast=0;fast<nums.length;++fast) {
			  if list[fast] != 0 {
			    // 关键的一步，可以将0换成后面的非0值
     			list[slow] = list[fast]
     			slow = slow + 1
				}
		}

		//所以第二次遍历把末尾的元素都赋为0即可
		for(int i=slow;i<nums.length;++i) {
			nums[i] = 0;
		}
```



### 双指针 1 次循环

除了也是双指针，核心上，有 **排序前后交换** 的思想。

其实就是将 2 次循环中，第 2 次循环赋 0 的工作，放到了循环当中去完成。

直接在循环体中多做了一步：

> 将慢指针为 0 的位置替换为非 0 值，同时将快指针非 0 位置，替换成 0 

反应到代码上就是：

        for fast in 0..<nums.count {
            if nums[fast] != 0 {//当前元素!=0，就把其交换到左边，等于0的交换到右边
                if (fast > slow) {// 避免了数组开头是非零元素的交换也就是阻止（i==j）时交换
                 nums[slow] = nums[fast];
                 nums[fast] = 0;
                }
                slow = slow + 1
            }
        }