# 反转链表 

反转一个单链表。

示例:

```
输入: 1->2->3->4->5->NULL
输出: 5->4->3->2->1->NULL
```

进阶:
你可以迭代或递归地反转链表。你能否用两种方法解决这道题？



# 思路

作为一个经典题目，一般有两种解题思路。

一个是迭代法，一个是递归法。

### 迭代法

又叫 **双指针法** 。 核心是通过循环，不断切换head，一直向前追溯和完成替换 tmp 链表。

最开始 ：

node= 1->2->3->4->5->NULL，first=1，tmp=NULL

第一次循环结束：

node= 2->3->4->5->NULL，first=2,  tmp=1->NULL，

第二次循环结束：

node= 3->4->5->NULL, first=3, tmp: 2->1->NULL，

...

随着循环的次数增加，tmp 链表不断的从头部插入节点，原来的链表不断的减少节点。

所以实际上就是核心是：

- 删除原链表的头节点（删除过程中，next 节点会不断顶上来）
- 将原链表的头节点，插入到新链表

关键点就在于利用 tmp 作为新链表的建立，然后不断将原来的头节点放进 tmp。

仔细想想，不就是倒球吗：



<img src="https://zenon-1255868537.cos.ap-guangzhou.myqcloud.com/blogPicture/202211022052083.png?imageMogr2/thumbnail/!50p"  />

### 递归法

递归法的理解，稍复杂一点，相当于从头节点，通过递归走到尾节点。

然后在**递归之中变换前后节点**。

因为要一直走到尾部节点，所以递归的中止条件为：当前节点为 空。

而反转工作，就在递归过程当中进行。

把链表放短一点去理解：

开始：1->2->NULL

递归调用一次：2->1->NULL

 
```
{//递归核心

next.next = currentHead;//完成对调，递归的原因就是不断重复这一过程

currentHead.next = nil;

}
```
